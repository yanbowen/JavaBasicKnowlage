# Java基础02  
<hr>  

## 选择排序  

	public static viod selectSort(int[] arr){
	
		for(int m=0; m<arr.length-1; m++){
			for(int n=m+1; n<arr.length;n++){
				if(arr[m]>arr[n]){
					int temp = arr[m];
					arr[m] = arr[n];
					arr[n] = temp;
				}
			}
		}
	}   
  
## 冒泡排序  

	public static viod bubbleSort(int[] arr){
	
		for(int m=0; m<arr.length-1; m++){
			for(int n=0; n<arr.length-m-1;n++){
				if(arr[n]>arr[n+1]){
					int temp = arr[n];
					arr[n] = arr[n+1];
					arr[n+1 ] = temp;
				}
			}
		}
	}   
  
排序函数
   
	Arrays.sort(arr);//从小到大排序

最快的排序方式：希尔排序  
  
## 数组查找  
折半查找：前提是该数组为有序数组  
 
	package althorgrim;  
	/** 
	 * 1、必须采用顺序存储结果 
	 * 2、关键字必须有序 
	 */  
	public class BinarySearch {  
      
    public static int binarySearch(int a[],int goal){  
        int high=a.length-1;  
        int low=0;  
        while (low<=high) {  
            int middle=(low+high)>>2;  
            if (a[middle]==goal) {  
                return middle;  
            }  
            else if (a[middle]>goal) {  
                high=middle-1;  
            }  
            else {  
                low=middle+1;  
            }  
        }  
        return -1;  
    }  
  
## 面向过程  
  
* 面向对象是相对于面向过程而言  
  
<hr>  
  
## 面向对象  
  
* 类 ：对现实生活中事物的描述。  
* 对象 ：这类事物，实实在在存在的个体。  (在堆内存中，new产生的实体)
* 成员变量 ： 存在于堆内存中  
* 局部变量 ： 存在于栈内存中  

<hr> 
  
## 匿名对象  

* 匿名对象是对象的简化形式；
* 使用情况
	* 当对象方法仅进行一次调用时；
	* 匿名对象可以作为实际参数进行传递；  

<hr>   
  
## 封装(Encapsulation)  
* 封装是指隐藏对象的属性和实现细节，仅对外提供公共访问方式
* 好处： 
	* 将变化隔离
	* 便于使用
	* 提高重用性
	* 安全性
* 封装原则 ：
	* 将不需要对外提供的内容都隐藏起来
	* 把属性都隐藏，提供公共方法对其访问  
  
私有仅仅是封装的一种表现形式。  
<hr>   
  
## 构造函数  
* 函数名与类名相同  
* 不用定义返回值类型  
* 不写return语句  
* 当类中自定义构造函数后，系统默认定义的构造函数就没有了  
* 构造函数在对象一建立就运行
  
## 构造代码块  
* 作用： 给对象进行初始化
* 对象一建立就运行，且优先于构造函数执行
* 构造代码块是给所有对象进行统一初始化
* 构造函数是定义不同初始化对象时使用

this使用：本类内部用到本类对象时使用  
构造函数间调用只能使用this，且只能定义在构造函数的第一行，因为初始化需要先执行  

<hr>   
  
## static  
* 用于修饰成员（成员变量和成员函数）(不能修饰局部)
* 被修饰后的成员具备以下特点
	* 随着类的加载而加载
	* 优先于对象存在
	* 被所有对象共享
	* 可以直接被类名调用
* 注意：
	* 静态方法只能访问静态成员（方法和变量）
	* 静态方法中不可以写this，super关键字
	* 主函数是静态的   

实例变量和类变量的区别：  

* 存放位置：
	* 类变量随着类的加载而存在于方法区中
	* 实例变量随着对象的建立而存在于堆内存中
* 生命周期：
	* 类变量生命周期最长，随着类的消失而消失
	* 实例变量生命周期随着对象的消失而消失  
   
弊端： 
	* 生命过长
	* 访问出现局限性  
  
方法设置为静态后，可以方便使用，但该类还是可以被其他程序建立对象，为了更加严谨，强制让该类不能建立对象，通过将构造函数私有化完成。  
  
static表示“全局”或者“静态”的意思，用来修饰成员变量和成员方法，也可以形成静态static代码块，但是Java语言中没有全局变量的概念。  
  
**被static修饰的成员变量和成员方法独立于该类的任何对象。**也就是说，它不依赖类特定的实例，被类的所有实例共享。只要这个类被加载，Java虚拟机就能根据类名在运行时数据区的方法区内定找到他们。因此，static对象可以在它的任何对象创建之前访问，无需引用任何对象。  
  
用public修饰的static成员变量和成员方法本质是全局变量和全局方法，当声明它类的对象市，不生成static变量的副本，而是类的所有实例共享同一个static变量。  

static变量前可以有private修饰，表示这个变量可以在类的静态代码块中，或者类的其他静态成员方法中使用（当然也可以在非静态成员方法中使用--废话），但是不能在其他类中通过类名来直接引用，这一点很重要。实际上你需要搞明白，**private是访问权限限定，static表示不要实例化就可以使用**，这样就容易理解多了。static前面加上其它访问权限关键字的效果也以此类推。  
  
1.static变量  

* 按照是否静态的对类成员变量进行分类可分两种：一种是被static修饰的变量，叫静态变量或类变量；另一种是没有被static修饰的变量，叫实例变量。两者的区别是：  
	* 对于静态变量在内存中只有一个拷贝（节省内存），JVM只为静态分配一次内存，在加载类的过程中完成静态变量的内存分配，可用类名直接访问（方便），当然也可以通过对象来访问（但是这是不推荐的）。
	* 对于实例变量，没创建一个实例，就会为实例变量分配一次内存，实例变量可以在内存中有多个拷贝，互不影响  

2.静态方法  

* 静态方法可以直接通过类名调用，任何的实例也都可以调用，因此静态方法中不能用this和super关键字，不能直接访问所属类的实例变量和实例方法(就是不带static的成员变量和成员成员方法)，只能访问所属类的静态成员变量和成员方法。因为实例成员与特定的对象关联！
* 因为static方法独立于任何实例，因此static方法必须被实现，而不能是抽象的abstract。  

3.static代码块  
  
* static代码块也叫静态代码块，是在类中独立于类成员的static语句块，可以有多个，位置可以随便放，它不在任何的方法体内，JVM加载类时会执行这些静态的代码块，如果static代码块有多个，JVM将按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次。  

4.修饰类  
 
* java里面static一般用来修饰成员变量或函数。但有一种特殊用法是用static修饰内部类，普通类是不允许声明为静态的，只有内部类才可以。被static修饰的内部类可以直接作为一个普通类来使用，而不需实例一个外部类（见如下代码）： 
   
![](https://i.imgur.com/AvSXrjB.jpg)

<hr>   
  
## 静态代码块  
特点： 随着类的加载而执行，只执行一次 

  
## 构造代码块  
由对象初始化构造代码块   
  
	public class exam {
	public static void main(String[] args) {

		new StaticDemo();// a  c9  b
	}
	}

	class StaticDemo {
	int num = 9;

	StaticDemo() {
		System.out.println("b");
	}

	static {
		System.out.println("a");
	}

	//构造代码块
	{
		System.out.println("c" + this.num);
	}

	StaticDemo(int x) {
		System.out.println("d");
	}
	}  
  
结果：a c9 b  
  
例子： Person p = new Person("zhangxxx",30);  

1. 因为new用到Person.class文件，会先找到该文件并加载到内存中。
2. 若有静态代码块，则先执行static代码块内容，给Person.class类进行初始化。
3. 在堆内存中开辟空间，分配内存地址。
4. 在对内存中建立对象的特有属性，并进行默认初始化。
5. 对属性进行显示初始化。
6. 对对象进行构造代码块初始化。
7. 对对象进行对应的构造函数初始化
8. 将内存地址赋给栈内存中的p变量   
  
   
方法区优先于对象存在，先加载   
  
静态方法在栈内存中建立，不能访问堆内存（静态方法不能访问非静态方法）
  

<hr>    
  
## 继承  
* 提高代码的复用性  
* 类与类直接才产生了关系，才有了多态的特性  
* 类与类之间要有所属关系才可以继承。is-a  
* java只支持单继承（多继承容易带来安全隐患）（多个父类中定义了相同的内容，子类对象不确定运行那个）（改良后以多实现方式出现）   
* 支持多层继承（想要使用体系，先查阅父类的描述，因为父类中定义的该体系中的共性内容）
  
### 聚集： has-a
### 聚合： 球员与球队的关系
### 组合： 一个对象可以包含另一个对象。这两个对象之间的关系称为组合（composition）。（手是人身体的一部分）

*	一个对象可以被几个其他聚集对象所拥有。如果一个对象只归属于一个聚集对象，那么它和聚集对象之间的关系就称为组合（composition）。  


* 依赖(Dependency)关系是类与类之间的联接。依赖关系表示一个类依赖于另一个类的定义。例如，一个人(Person)可以买车(car)和房子(House)，Person类依赖于Car类和House类的定义，因为Person类引用了Car和House。与关联不同的是，Person类里并没有Car和House类型的属性，Car和House的实例是以参量的方式传入到buy()方法中去的。一般而言，依赖关系在Java语言中体现为局域变量、方法的形参，或者对静态方法的调用。 

* 关联(Association）关系是类与类之间的联接，它使一个类知道另一个类的属性和方法。关联可以是双向的，也可以是单向的。在Java语言中，关联关系一般使用成员变量来实现。 

* 聚合(Aggregation) 关系是关联关系的一种，是强的关联关系。聚合是整体和个体之间的关系。例如，汽车类与引擎类、轮胎类，以及其它的零件类之间的关系便整体和个体的关系。与关联关系一样，聚合关系也是通过实例变量实现的。但是关联关系所涉及的两个类是处在同一层次上的，而在聚合关系中，两个类是处在不平等层次上的，一个代表整体，另一个代表部分。 

* 组合(Composition) 关系是关联关系的一种，是比聚合关系强的关系。它要求普通的聚合关系中代表整体的对象负责代表部分对象的生命周期，组合关系是不能共享的。代表整体的对象需要负责保持部分对象和存活，在一些情况下将负责代表部分的对象湮灭掉。代表整体的对象可以将代表部分的对象传递给另一个对象，由后者负责此对象的生命周期。换言之，代表部分的对象在每一个时刻只能与一个对象发生组合关系，由后者排他地负责生命周期。部分和整体的生命周期一样。  
  

<hr>     

## 重写（覆盖）与重载  
* 重载（overload）：对于类的方法（包括从父类中继承的方法），方法名相同，参数列表不同的方法之间就构成了重载关系。  
	* 什么叫参数列表？参数列表又叫参数签名，指三样东西：参数的类型，参数的个数，参数的顺序。这三者只要有一个不同就叫做参数列表不同。
	* 重载关系只能发生在同一个类中吗？非也。这时候你要深刻理解继承，要知道一个子类所拥有的成员除了自己显式写出来的以外，还有父类遗传下来的。所以子类中的某个方法和父类中继承下来的方法也可以发生重载的关系。  
	
大家在使用的时候要紧扣定义，看方法之间是否是重载关系，不用管方法的修饰符和返回类型以及抛出的异常，只看方法名和参数列表。而且要记住，构造器也可以重载。  

* 覆盖 (override)：也叫重写，就是在当父类中的某些方法不能满足要求时，子类中改写父类的方法。当父类中的方法被覆盖了后，除非用super关键字，否则就无法再调用父类中的方法了。
* 发生覆盖的条件：
	1. “三同一不低” 子类和父类的方法名称，参数列表，返回类型必须完全相同，而且子类方法的访问修饰符的权限不能比父类低。
	2. 子类方法不能抛出比父类方法更多的异常。即子类方法所抛出的异常必须和父类方法所抛出的异常一致，或者是其子类，或者什么也不抛出；
	3. 被覆盖的方法不能是final类型的。因为final修饰的方法是无法覆盖的。
	4. 被覆盖的方法不能为private。否则在其子类中只是新定义了一个方法，并没有对其进行覆盖。
	5. 被覆盖的方法不能为static。所以如果父类中的方法为静态的，而子类中的方法不是静态的，但是两个方法除了这一点外其他都满足覆盖条件，那么会发生编译错误。反之亦然。即使父类和子类中的方法都是静态的，并且满足覆盖条件，但是仍然不会发生覆盖，因为静态方法是在编译的时候把静态方法和类的引用类型进行匹配。(静态只能覆盖静态)    
 
* 子类对象进行初始化时，父类构造函数也会进行初始化，原因在于，子类构造函数默认第一行有一条隐式语句super()；
* 子类为什么要访问父类（所有子类构造函数中默认第一行都是super();）
  
